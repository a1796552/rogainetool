Contribution
	I focused on the back end of the program. I designed the structure of the routePlanner and checkpoint classes and how they interacted with each other 
    and created the dynamic programming optimal algorithm. Also assisted in the code for the main file and README documentation.

Learning Experience and reflection
    The problem could be broken down into something similar to a knapsack problem with the goal being to maximise the points scored without exceeding the 
    max distance. It was interesting to get hands on experience with some of the techniques that I have been practising through the weekly problems. I also 
    was able to recognise the advantage of implementing different algorithms for the same problem under different conditions. The DP approach was 
    not capable of running quickly if the amount of points exceeded 12 so there needed to be another algorithm that would be able to give a result when the 
    amount of points exceeded that amount. By implementing the DP for 12 or less points and greedy for 13 or more allowed for the program to get a good
    mix of accuracy for easier problems while still producing an effective solution for larger problems. The program overall satisfies the goals that we
    set out to achieve. Something I would've liked to improve is to optimise the DP solution that I made so it could be used for calculations of more than
    12 points.
	
